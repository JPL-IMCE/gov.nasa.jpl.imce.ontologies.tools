---
title: "Two Algorithms for Taxonomy Disjointness Maintenance"
author: "J S Jenkins"
date: 2019-05-03
output:
  html_document:
    df_print: paged
  pdf_document: default
---
# Introduction

One of the key features of the Semantic Web (and its formal foundations in Description Logic) is the so-called _open-world semantics_, which means simply that any unasserted fact may be true or false. The real world is open in just this way, although we rarely think about. If I do not assert that I am an alumnus of UCLA, then (at least logically) I might or might not be.

Open-world semantics do not apply in traditional database applications. If my name does not appear in the table of customers, then an application is justified in concluding I am not (yet) a customer.

Neither open- nor closed-world semantics are correct, per se. Each has its appropriate uses, and it is important to be aware of the semantics in effect and draw proper conclusions.

One aspect of open-world semantics that is sometimes surprising to people familiar with object-oriented software development has to do with implicit _disjointness_. If, for example, in Java, we declare classes as follows:

```
// Java
public class Vehicle {}
public class Person {}
```

we naturally expect that an object may be a `Vehicle` or it may be a `Person`, but it cannot be both. That is, the sets of objects of type `Vehicle` and `Person` are _disjoint_. Formally, two sets are disjoint if their intersection is empty.

If instead, however, we want to declare classes that are not disjoint because one is a subclass of the other, Java requires us to declare the relation explicitly:

```
// Java
public class Vehicle {}
public class Car extends Vehicle {}
```

The situation with OWL and the Semantic Web is somewhat different. If we declare OWL classes

```
# OWL
Declaration(Class(Vehicle))
Declaration(Class(Person))
Declaration(Class(Car))
```

and assert nothing further, then any pair of classes may have a nonempty intersection. To assert the the situation from the Java example, we must add two axioms:

```
# OWL
DisjointClasses(Vehicle Person)
SubClassOf(Car Vehicle)
```

Note that we do not need to assert `DisjointClasses(Car Person)`; that fact follows from the definition of disjointness; a DL reasoner will infer it. Note also that, while it probably not what we mean, it would not be logically inconsistent to assert `DisjointClasses(Car Vehicle)`; the reasoner would correctly include that the set of cars is _empty_, but the empty set is a perfectly valid set. A class that can have no members is said to be _unsatisfiable_.

# Disjointness Maintenance

The general problem of disjointness maintenance is the augmentation of a taxonomy with disjointness axioms that encode a specific policy for vocabulary closure. It is of utmost importance to note that these disjointness axioms are in no sense _implied_ by the taxonomy itself; indeed, the open world interpretation is that two classes are not considered to be disjoint unless explicitly declared to be so or if their disjointness is implied by mutually exclusive constraints such as property range or cardinality restrictions.

The policy to be implemented here is simple: any two classes that have no common subclass are considered to be disjoint. A simple corollary is that, if _B_ is a subclass of _A_, then _A_ and _B_ are not disjoint because _A_ and _B_ have a common subclass, namely _B_. Also note that disjointness is inherited: if _A_ and _B_ are disjoint, then every subclass of _A_ is disjoint with every subclass of _B_. We can use this fact to make our generated disjointness axioms concise.

The objectives of a disjointness maintenance algorithm, therefore, are threefold:

1. to implement the disjointness policy,
1. to minimize the number of disjointness axioms generated, and
1. to generate disjointness axioms of tractable computational complexity for a reasoner.

The last item is beyond the expertise of the author. We focus on the first two and hope for the best with the third.

```{r message=FALSE, warning=FALSE}
source("bundle-closure.R")
```

## The Simplest Case

Consider the case of a taxonomy that is a _directed rooted tree_ in the graph-theoretic sense. A _tree_ is an undirected
graph that is connected and acyclic. (An equivalent formulation is that there is exactly one path between any two vertices.)
A _directed tree_ is a tree in which the edges are directed, and a _rooted tree_ is a directed tree in which a single vertex is
designated the _root_. For this discussion we will take edge direction to be from subclass to superclass; the root vertex corresponds
to `owl:Thing`.
```{r}
plot_tree(sym7_tree, sym7_layout)
```

It is easy to show that declaring all sibling subclasses of any common superclass disjoint satisfies the disjointness policy. We prove it
in two steps:

1. *Necessity*: Any two sibling subclasses 
_A_ and _B_ of a common superclass cannot share a common subclass. If a common subclass existed, there would be two
paths to the root from it: one through _A_ and one through _B_. Every tree contains exactly one path between any pair of vertices,
so a common subclass cannot exist.

1. *Sufficiency*: If two classes _A_ and _B_ do not share a common subclass, then neither one is a subclass of the other. Consequently,
the path from _A_ to the root contains at least one edge not in the path from _B_ to the root and vice versa. Therefore, there must
exist some vertex _C_ (perhaps the root) where the paths from _A_ to the root and from _B_ to the root converge. That is, there must exists sibling
subclasses _C<sub>A</sub>_ and _C<sub>B</sub>_ such that _A_ is a subclass of _C<sub>A</sub>_ and _B_ is a subclass of _C<sub>B</sub>_.

The disjointness algorithm for a tree is therefore simple:

1. Traverse the tree
2. Declare the sibling subclasses of each parent class disjoint

For our example problem, the result is
```
DisjointClasses( b c )
DisjointClasses( d e )
DisjointClasses( f g )
DisjointClasses( h i )
```

# Two Algorithms

## Example Cases

### Simple Diamond

```{r}
plot_tree(diam_tree, diam_layout)
```


### Symmetric 8

```{r}
plot_tree(sym8_tree, sym8_layout)
```

### Asymmetric

```{r}
plot_tree(asym_tree, asym_layout)
```

### Up-Down-Left-Right

```{r}
plot_tree(udlr_tree, udlr_layout)
```

## Merge

### Simple Diamond

```{r}
plot_tree(diam_after_merge_tree)
```

### Symmetric 8

```{r}
plot_tree(sym8_after_treeify_using_merge_tree, sym8_after_treeify_using_merge_layout)
```

### Asymmmetric

```{r}
plot_tree(asym_after_merge_tree)
```

### Up-Down-Left-Right

```{r}
plot_tree(udlr_after_merge_tree, udlr_after_merge_layout)
```

## Bypass-Reduce-Isolate

### Simple Diamond

```{r}
plot_tree(diam_after_bypass_reduce_isolate_tree)
```

### Symmetric 8
 
```{r}
plot_tree(sym8_after_treeify_using_bypass_reduce_isolate_tree, sym8_after_treeify_using_bypass_reduce_isolate_layout)
```

### Asymmetric

```{r}
plot_tree(asym_after_bypass_reduce_isolate_tree, asym_after_bypass_reduce_isolate_layout)
```

### Up-Down-Left-Right

```{r}
plot_tree(udlr_after_bypass_reduce_isolate_tree, udlr_after_bypass_reduce_isolate_layout)
```

# The General Procedure

1. Excise Pure Aspects
1. Excise Backbone Classes
1. Perform Transitive Reduction
1. Treeify
1. Find Sibling Classes
1. Assert Disjointness

# Prototype Implementation
