#!/usr/bin/env ruby

#--
#
#    $HeadURL$
#
#    $LastChangedRevision$
#    $LastChangedDate$
#
#    $LastChangedBy$
#
#    Copyright (c) 2008-2014 California Institute of Technology.
#    All rights reserved.
#
#++

require 'getoptlong'
require 'guid'
require 'logger'
require 'rexml/document'
require 'tsort'
require 'jpl/rdf/sesame'

# Define constants.

# Define structs.

# Define variables.

temp_context = nil
imports_by_ontology = Hash.new { |h, k| h[k] = Set.new }

# Define utility functions.

class Hash
  def close(k, stop = [])
    self[k].inject(Set.new) do |m, o|
      unless stop.any? { |s| o =~ s }
        m << o
        m += self.close(o, stop)
      end
      m
    end
  end
end

#  Define modules.

module TSortMethods
  include TSort
  def tsort_each_node(&block)
    each_key(&block)
  end
  def tsort_each_child(node, &block)
    begin
      self.fetch(node).each(&block)
    rescue IndexError
    end
  end
end

# Process arguments.

def usage
  warn 'construct-disjoints --host host --port port --path path --repo repo in_uri'
end

log_level = Logger::FATAL
host = 'localhost'
port = '8080'
path = 'openrdf-sesame'
repo = 'imce-ontologies-dev'
in_uri = nil

GetoptLong.new(
[ '--help',    '-h',       GetoptLong::NO_ARGUMENT ],
[ '--debug',   '-d',       GetoptLong::NO_ARGUMENT ],
[ '--info',    '-i',       GetoptLong::NO_ARGUMENT ],
[ '--warn',    '-w',       GetoptLong::NO_ARGUMENT ],
[ '--repo',    '-r',       GetoptLong::REQUIRED_ARGUMENT ],
[ '--host',                GetoptLong::REQUIRED_ARGUMENT ],
[ '--port',                GetoptLong::REQUIRED_ARGUMENT ],
[ '--path',                GetoptLong::REQUIRED_ARGUMENT ]
).each do |opt, arg|
  case opt
  when "--help"
    usage
    exit 0
  when "--debug"
    log_level = Logger::DEBUG
  when "--info"
    log_level = Logger::INFO
  when "--warn"
    log_level = Logger::WARN
  when "--host"
    host = arg
  when "--port"
    port = arg
  when "--path"
    path = arg
  when "--repo"
    repo = arg
  else
    warn "unknown option: #{opt}"
    usage
    exit 1
  end
end

if ARGV.length == 1
  in_uri = *ARGV
else
  usage
  exit 1
end
  
unless host && port && path && repo && in_uri
  usage
  exit 1
end

# Open log.

log = Logger.new(STDERR)
log.datetime_format = '%Y-%m-%d %H:%M:%S '
log.level = log_level

# Connect to Sesame server.

log.info('begin session')
session = RDF::Sesame::Session.new(host, port, path, log)
raise 'no session' unless session
log.info('create model')
model = session.model(repo)
raise 'no model' unless model

# Get repository namespace defintions.

nsm = {}
namespace_by_prefix = {}
model.namespaces.map do |defn|
  prf = defn.prefix.to_s
  ns = defn.namespace.to_s
  nsm[prf] = RDF::NamespaceMap.new(ns)
  namespace_by_prefix[prf] = ns
end
RDF::Uri.ns_by_prf = namespace_by_prefix

# Construct namespace definition string.

namespace_defs = nsm.map do |prf, ns|
  "PREFIX #{prf}:#{nsm[prf][''].to_uriref}"
end.join("\n")

# Find ontologies and imports.

log.info('find ontologies and imports')
qstring = %Q{
  #{namespace_defs}
  select distinct ?ontology ?import ?noMapping
  where {
    ?ontology rdf:type owl:Ontology .
    optional {
      ?ontology owl:imports ?import .
    }
    optional {
      ?ontology annotation:noMapping ?noMapping .
    }
  }
}
log.debug(qstring)
model.query({'query' => qstring, 'infer' => 'false'}) do |resp|
  ontology = RDF::Uri.new(resp.ontology.to_s)
  if import = resp.import
    import = RDF::Uri.new(import.to_s)
    imports_by_ontology[ontology] << import
    log.debug("#{ontology} imports #{import}")
  end
end
imports_by_ontology.extend(TSortMethods)
log.debug("imports_by_ontology: #{imports_by_ontology.inspect}")
sorted_ontologies = imports_by_ontology.tsort.reverse
log.debug("sorted_ontologies: #{sorted_ontologies.inspect}")

# Construct closures and from clauses.

imports_closure = imports_by_ontology.close(in_uri) << RDF::Uri.new(in_uri)
log.debug("imports closure: #{imports_closure.inspect}")

imports_closure += imports_closure.map { |ont| RDF::Uri.new(ont.to_s + '/ClassEntailments') }
from_clauses = imports_closure.map { |ont| "from #{ont.to_uriref}" }.join("\n")
  
# Delete temporary context on exit.

at_exit do
  if temp_context
    log.debug("delete context #{temp_context}")
    model.delete_statements({'context' => temp_context})
  end
end

# Construct disjoint axioms.

query = %Q{

  #{namespace_defs}

  construct { ?klass1 owl:disjointWith ?klass2 }
  
  #{from_clauses}
  
  where {
  
    ?klass1 rdfs:subClassOf UML:Element .
    ?klass2 rdfs:subClassOf UML:Element .
    
    optional {
      ?common rdfs:subClassOf ?klass1 .
      ?common rdfs:subClassOf ?klass2 .
      filter (?common != owl:Nothing)
    }
    
    filter (
         str(?klass1) < str(?klass2)
    && not exists { ?klass1 annotation:isAbstract true }
    && not exists { ?klass2 annotation:isAbstract true }
    && ?klass1 != owl:Nothing
    && ?klass2 != owl:Nothing
    && !bound(?common)
    )
    
  }
}
log.debug("disjoints query #{query}")
input = model.query_statements({'query' => query, 'infer' => 'false'})
  
# Load temporary context.

temp_uri = RDF::Uri.new('http://dummy.org/' + Guid.new.to_s)
temp_context = temp_uri.to_uriref
input << RDF::Statement.new(temp_uri, nsm['rdf']['type'], nsm['owl']['Ontology'])
log.debug("import #{input.length} statements to context #{temp_context}")
model.add_statements(input, {'context' => temp_context})

# Write output ontology.

log.debug("export temporary context #{temp_context}")
output = model.export({'context' => temp_context})
log.debug("write #{output.lines.count} lines to stdout")
puts output
  
# End session.

log.info('end')
session.finish