#!/usr/bin/env ruby

#--
#
#    $HeadURL: https://sscae-cm.jpl.nasa.gov/svn/ontologies/trunk/gov.nasa.jpl.imce.ontologies/tools/validate-owl $
#
#    $LastChangedRevision: 3623 $
#    $LastChangedDate: 2014-03-25 20:04:39 -0700 (Tue, 25 Mar 2014) $
#
#    $LastChangedBy: sjenkins $
#
#    Copyright (c) 2008-2014 California Institute of Technology.
#    All rights reserved.
#
#++

require 'csv'
require 'json'
require 'Application'

APPLICATION_NAME = 'iri-to-mdid'

class IriToMdid < Application

  def run

    @options.metadata = nil
    option_parser.on('--metadata METADATA', "exported OMF metadata file") do |v|
      @options.metadata = v
    end
    @options.provenance = nil
    option_parser.on('--provenance PROVENANCE', "provenance file") do |v|
      @options.provenance = v
    end
    
    super
    
    # Load metadata.
    
    logger.log(INFO, "load metadata from #{@options.metadata}")
    metadata_file = File.new(@options.metadata)
    raise "no metadata file #{@options.metadata}" unless metadata_file
    metadata = JSON.parse(metadata_file.read)
    raise "couldn't load metadata" unless metadata
    
    # Load provenance data.
    
    logger.log(INFO, "load provenance data from #{@options.provenance}")
    prov_file = File.open(@options.provenance)
    raise "no provenance file #{@options.provenance}" unless prov_file
    provenance = prov_file.inject([]) do |memo, row|
      memo << JSON.restore(row)
      memo
    end
    raise "couldn't load provenance" unless provenance
    
    # Build metadata hash.
    
    logger.log(Logger::INFO, 'collect provenance data')
    md_hash = build_provenance_hash(metadata, provenance, has_iri, has_uuid)
    md_hash.each do |k, v|
      logger.log(Logger::DEBUG, "md_hash #{k.inspect} => #{v.inspect}")
    end
    
    # Iterate over input IRIs.
    
    logger.log(Logger::INFO, 'process unsatisfiable classes')
    csv_in = CSV.new(ARGF)
    headers = csv_in.gets
    klass_sub = headers.find_index('class')
    raise "no 'class' column found in input" unless klass_sub
    csv_out = CSV.new(STDOUT)
    csv_out << headers + %w{ md_url md_id }
    csv_in.each do |row|
      iri = row[klass_sub]
      logger.log(Logger::DEBUG, "csv out #{iri.inspect}")
      h = md_hash[iri] || %w{ missing missing }
      csv_out << row + h
    end
    
    # Return.
    
    return 0
	    
  end
  
  def build_provenance_hash(metadata, provenance, has_iri, has_uuid)
    prov_map = provenance.inject({}) do |m, p|
      k = p['omlUUID']
      m[k] = [p['otiURL'], p['otiID']]
      logger.log(Logger::DEBUG, "prov_map #{k.inspect} => #{m[k].inspect}")
      m
    end
    metadata['nodes'].inject({}) do |h, node|
      iri = node['iri']
      uuid = node['uuid']
      if iri && uuid
        h[iri] = prov_map[uuid]
        logger.log(Logger::DEBUG, "prov_hash #{iri} => (prov_map[#{uuid}] = #{h[iri].inspect})")
      end
      h
    end
  end
  
 end

exit(IriToMdid.new(APPLICATION_NAME).start)
