#!/usr/bin/env ruby

#--
#
# Copyright 2018 California Institute of Technology ("Caltech").
# U.S. Government sponsorship acknowledged.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#++

# close-bundle loads an bundle ontology specifed by its IRI (and its imports) and produces on standard output
# the corresponding bundle closure ontology. A bundle closure contains the smallest set of OWLDisjointClassesAxioms
# such that any two classes that do not have an explicit intersection are disjoint.

require 'OWLAPIApplication'
require 'taxonomy'

java_import 'uk.ac.manchester.cs.owl.owlapi.OWLDataFactoryImpl'
java_import 'org.coode.xml.XMLWriterPreferences'
java_import 'org.semanticweb.owlapi.model.AddImport'
java_import 'org.semanticweb.owlapi.model.AxiomType'
java_import 'org.semanticweb.owlapi.model.ClassExpressionType'

ANNOTATIONS = %w{ importsBundle }
APPLICATION_NAME = 'close-tbox-bundle'

class CloseBundleApplication < OWLAPIApplication
  
  def run
    
    option_parser.on('--name NAME', 'bundle name (required)') do |v|
      @options.name = v
    end
    option_parser.on('--uri URI', 'bundle uri (required)') do |v|
      @options.uri = v
    end
    @options.namespace = {}
    option_parser.on('--namespace PREFIX=>NAMESPACE', "namespace prefix definition (2 required)") do |v|
      p, n = v.split(/\s*=>\s*/)
      if (p.empty? || n.empty?)
        log(FATAL, "invalid namespace definition '#{v}'")
      end
      @options.namespace[p] = n
    end
    option_parser.on('--embedding', "embedding bundle") do
      @options.embedding = true
    end
    @options.iri_file = nil
    option_parser.on('--iri-file FILE', 'input IRI file [nil]') do |v|
      @options.iri_file = v
    end
    @options.excise_pattern = nil
    option_parser.on('--excise PATTERN', 'excise classes with IRIs matching PATTERN') do |v|
      @options.excise_pattern = Regexp.new(v)
    end
    @options.backbone_iri = 'http://imce.jpl.nasa.gov/backbone/'
    option_parser.on('--backbone_iri IRI', '') do |v|
      @options.backbone_iri = v
    end
    @options.backbone_stems = {}
    option_parser.on('--abstract "stem1 stem2 ... " ', '') do |v|
      @options.backbone_stems[:abstract] = v.split(/\s+/)
    end
    option_parser.on('--concrete "stem1 stem2 ... " ', '') do |v|
      @options.backbone_stems[:concrete] = v.split(/\s+/)
    end

    super
    
    if @options.name.nil?
      log(FATAL, 'no bundle name')
      return 1
    end
    if @options.uri.nil?
      log(FATAL, 'no bundle uri')
      return 1
    end
    if argv.empty? && @options.iri_file.nil?
      log(FATAL, 'no named ontologies')
      return 1
    end
    unless @options.namespace.keys.length == 2
      log(FATAL, '2 namespace definitions required')
      return 1
    end
    if @options.backbone_stems[:abstract]
      unless @options.backbone_stems[:concrete]
        log(FATAL, '--abstract specified but not --concrete')
        return 1
      end
    else
      if @options.backbone_stems[:concrete]
        log(FATAL, '--concrete specified but not --abstract')
        return 1
      end
    end
    
    # Axiom storage.
    
    axioms = java.util.HashSet.new
      
    # Create ontology manager.
    
    log(INFO, 'create ontology manager')
    manager = OWLManager.create_owl_ontology_manager
    log(INFO, 'add location mappers')
    location_mappers.each do |mapper|
      manager.add_iri_mapper(mapper)
    end

    # Get IRI list to load.

    if @options.iri_file
      begin
        iris = File.open(@options.iri_file).readlines.map { |l| l.strip }
      rescue
        log(FATAL, "error reading IRI file #{@options.iri_file}")
        raise $!
      end
    else
      iris = argv
    end
    
    # Load ontologies.

    log(INFO, 'load ontologies')
    total = iris.length
    n = 0
    ontologies = iris.map do |arg|
      n += 1
      log(DEBUG, "load ontology #{arg} (#{n} of #{total})")
      manager.loadOntology(IRI.create(arg))
    end
    format = manager.getOntologyFormat(ontologies.first)
    imports_set = ontologies.inject(java.util.HashSet.new) do |m, o|
      m += manager.getImportsClosure(o)
      m
    end

    loaded = manager.getOntologies()
    log(DEBUG, "loaded #{loaded.length} ontologies")
    loaded.each do |l|
      log(DEBUG, "loaded #{l.getOntologyID.getOntologyIRI.toString}")
    end
    
    # Create data factory.

    log(INFO, 'create data factory')
    factory = OWLDataFactoryImpl.new
    
    # Set XML serialization preferences.

    log(INFO, 'set XML serialization preferences')
    xml_prefs = XMLWriterPreferences.get_instance
    xml_prefs.set_use_namespace_entities(true)
    
    # Create annotation properties.

    log(INFO, 'create annotation properties')
    annotations = ANNOTATIONS.inject({}) do |h, ps|
      p_iri = format.getIRI('annotation:' + ps)
      p = factory.getOWLAnnotationProperty(p_iri)
      h[ps] = p
      h
    end
    
    # Create ontology.
    
    log(INFO, "create ontology for #{@options.uri}")
    ontology = manager.createOntology(IRI.create(@options.uri))
    
    # Add ontology imports.

    log(INFO, 'add ontology imports')
    iris.each do |import|
      log(DEBUG, "add imports declaration for #{import}")
      decl = factory.getOWLImportsDeclaration(IRI.create(import))
      import = AddImport.new(ontology, decl)
      manager.applyChange(import)
    end
    
    # Add ontology annotations.

    log(INFO, 'add ontology annotations')
    { 'rdfs:comment' => "created by #{APPLICATION_NAME}", 'owl:versionInfo' => Time.new.to_s }.each do |ps, vs|
      p_iri = format.getIRI(ps)
      p = factory.getOWLAnnotationProperty(p_iri)
      v = factory.getOWLLiteral(vs)
      ann = factory.getOWLAnnotation(p, v)
      change = AddOntologyAnnotation.new(ontology, ann)
      manager.applyChange(change)
    end

    # Bundle closure is largely redundant for embedding ontologies.
    
    unless @options.embedding
      
      # Create class taxonomy.

      log(INFO, 'create class taxonomy')
      taxonomy_stage0 = Taxonomy.new
      total = ontologies.length
      n = 0
      klass_set = {}
      ontologies.each do |o|
        n += 1
        log(DEBUG, "subclasses in #{o.getOntologyID.getOntologyIRI.toString} (#{n} of #{total})")
        o.getClassesInSignature(true).each do |klass|
          unless klass.isAnonymous
            klass_iri = klass.asOWLClass.getIRI.toString
            klass_set[klass_iri] ||= Union.new([klass_iri])
            klass.getSubClasses(imports_set).reject do |sc|
              sc.isAnonymous
            end.map do |sc|
              sc.asOWLClass.getIRI.toString
            end.each do |sub_iri|
              sub_set = (klass_set[sub_iri] ||= Union.new([sub_iri]))
              log(DEBUG, "#{sub_iri} subclass of #{klass_iri}")
              taxonomy_stage0.add_edge(klass_set[klass_iri], sub_set)
            end
          end
        end
      end
      raise 'class taxonomy is cyclic' unless taxonomy_stage0.acyclic?

      # Root tree at OWL:Thing

      log(INFO, 'root tree at OWL:Thing')
      thing = factory.getOWLClass('owl:Thing', format)
      taxonomy_stage1 = taxonomy_stage0.root_at(Union.new([thing]))
      raise 'rooted class taxonomy is cyclic' unless taxonomy_stage1.acyclic?

      # Find all aspects (non-concrete classes).

      unless @options.backbone_stems[:abstract].empty? || @options.backbone_stems[:concrete].empty?
        log(INFO, 'find pure aspects')
        all_classes = {}
        @options.backbone_stems.each do |type, stems|
            pats = stems.map do |s|
            Regexp.new('\A' + @options.backbone_iri + '[^#]*#' + s + '\z')
          end
          bb_classes = taxonomy_stage1.vertices.select do |v|
            pats.any? { |p| v.first =~ p }
          end.uniq
          all_classes[type] = bb_classes.flat_map do |c|
            taxonomy_stage1.descendants_of(c)
          end.to_set
        end
        aspects = all_classes[:abstract] - all_classes[:concrete]
        log(INFO, "found #{aspects.length} pure aspects")

        # Excise aspects.

        log(INFO, 'excise aspects')
        taxonomy_stage2 = taxonomy_stage1.excise_vertices(aspects) do |msg, klass, done|
          case msg
          when :excising
            ks = '[' + klass.to_a.join(',') + ']'
            log(DEBUG, "excise #{ks}, #{done} done")
          when :excised
            log(INFO, "excised #{done} aspects")
          end
        end
      else
        taxonomy_stage2 = taxonomy_stage1
      end
      raise 'concrete class taxonomy is cyclic' unless taxonomy_stage2.acyclic?
        
      # Excise backbone classes.

      if pat = @options.excise_pattern
        log(INFO, 'excise backbone classes')
        taxonomy_stage3 = taxonomy_stage2.excise_pattern(pat) do |msg, klass, done|
          case msg
          when :excising
            ks = '[' + klass.to_a.join(',') + ']'
            log(DEBUG, "excise #{ks}, #{done} done")
          when :excised
            log(INFO, "excised #{done} backbone classes")
          end
        end
      else
        taxonomy_stage3 = taxonomy_stage2
      end
      raise 'backbone-free class taxonomy is cyclic' unless taxonomy_stage3.acyclic?

      # Perform transitive reduction.

      log(INFO, 'form transitive reduction')
      taxonomy_stage4 = taxonomy_stage3.transitive_reduction
      raise 'reduced class taxonomy is cyclic' unless taxonomy_stage4.acyclic?
      
      # Treeify class taxonomy.

      log(INFO, 'treeify class taxonomy')
      tree = taxonomy_stage4.treeify do |msg, tree, child, parents, done|
        case msg
        when :merging
          log(DEBUG, "merge #{parents.length} parents of #{child.to_a.join(',')}, #{done} done")
          parents.each do |p|
            log(DEBUG, "parent: #{p.to_a.join(',') }")
          end
        when :merged
          log(INFO, "merged #{done} vertices")
        end
      end
      raise 'merged tree is cyclic' unless tree.acyclic?

      # Create sibling groups.
      
      log(INFO, 'create sibling groups')
      sibling_groups = tree.sibling_groups

      # Create disjointness axioms.

      log(INFO, 'create disjointness axioms')
      sibling_groups.each do |sibs|
        expression = class_expression(sibs, factory)
        axioms << factory.getOWLDisjointClassesAxiom(expression)
      end

      # Add axioms to ontology.

      axioms.each do |axiom|
        log(DEBUG, "add axiom #{axiom}")
        manager.add_axiom(ontology, axiom)
      end
      log(INFO, "added #{axioms.length} disjointness axioms")

    end
    
    # Construct format specification for RDF/XML.
    
    rdfxml_format = RDFXMLOntologyFormat.new
    
    # Copy prefixes from first bundled ontology.
    
    rdfxml_format.copyPrefixesFrom(format)
    
    # Add prefixes for bundle.
    
    @options.namespace.each do |p, n|
      u = n + '#'
      log(DEBUG, "set prefix #{p} -> #{u}")
      rdfxml_format.setPrefix(p, u)
    end
    
    # Write modified ontology in OWL/XML.
  
    manager.save_ontology(ontology, rdfxml_format, STDOUT.to_outputstream)
    
    # Exit.
    
    return 0
          
  end
  
  # Create an OWL Class or a union of Classes from a list.
  
  def class_expression(disjoint_set, factory)
    result = java.util.HashSet.new
    disjoint_set.each do |union_list|
      case union_list.length
      when 1
        result << factory.getOWLClass(IRI.create(union_list.first.to_s))
      else
        union_hash = union_list.inject(java.util.HashSet.new) do |m, c|
          m << factory.getOWLClass(IRI.create(c.to_s))
          m
        end
        result << factory.getOWLObjectUnionOf(union_hash)
      end
    end
    result
  end
  
end

exit(CloseBundleApplication.new(APPLICATION_NAME).start)
