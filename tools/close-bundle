#!/usr/bin/env ruby

#--
#
#    $HeadURL$
#
#    $LastChangedRevision$
#    $LastChangedDate$
#
#    $LastChangedBy$
#
#    Copyright (c) 2008-2014 California Institute of Technology.
#    All rights reserved.
#
#++

require 'getoptlong'
require 'logger'
require 'tempfile'
require 'time'
require 'tsort'
require 'yaml'

require 'jpl/rdf/sesame'

include REXML

# Define constants.

WWW_OMG_ORG = 'http://imce.jpl.nasa.gov/www.omg.org'
WWW_OMG_ORG_ES = Regexp.escape(WWW_OMG_ORG)
WWW_OMG_ORG_RE = Regexp.new(WWW_OMG_ORG_ES)
WWW_OMG_ORG_SPARQL_RE = WWW_OMG_ORG_ES.gsub(/\\/, '\\\\\\')

WWW_W3_ORG = 'http://www.w3.org'
WWW_W3_ORG_ES = Regexp.escape(WWW_W3_ORG)
WWW_W3_ORG_RE = Regexp.new(WWW_W3_ORG_ES)
WWW_W3_ORG_SPARQL_RE = WWW_W3_ORG_ES.gsub(/\\/, '\\\\\\')

IMCE_JPL_NASA_GOV = 'http://imce.jpl.nasa.gov'
IMCE_JPL_NASA_GOV_ES = Regexp.escape(IMCE_JPL_NASA_GOV)
IMCE_JPL_NASA_GOV_RE = Regexp.new(IMCE_JPL_NASA_GOV_ES)
IMCE_JPL_NASA_GOV_SPARQL_RE = IMCE_JPL_NASA_GOV_ES.gsub(/\\/, '\\\\\\')

PURL_ORG = 'http://purl.org/dc/elements'
PURL_ORG_ES = Regexp.escape(PURL_ORG)
PURL_ORG_RE = Regexp.new(PURL_ORG_ES)
PURL_ORG_SPARQL_RE = PURL_ORG_ES.gsub(/\\/, '\\\\\\')

EMBEDDING = '-embedding'
EMBEDDING_RE = /#{EMBEDDING}\z/

REQUIRED_IMPORTS = [ [ 'embedding', 'cmof' ] ]
EXTRANEOUS_IMPORTS = [ [ 'cmof', [ 'embedding'] ], ]

# Define structs.

EntityStruct = Struct.new(:mapped, :text)
SubpropertyStruct = Struct.new(:domain_ok, :range_ok)
RestrictionStruct = Struct.new(:domain_ok, :range_ok)
SubpropertyMappingStruct = Struct.new(:rel_ok, :src_ok, :trg_ok)

# Define variables.

imports_by_ontology = Hash.new { |h, k| h[k] = Set.new }
closure_by_ontology = Hash.new { |h, k| h[k] = Set.new }
noMapping_by_ontology = {}
  
maps = {}

# Define utility functions.

def equal_any(var, list)
  '(' + list.map { |val| "#{var} = #{val}" }.push('false').join(' || ') + ')'
end

class String
  def context(append = nil)
    RDF::Uri.new(self + (append ||= '')).to_uriref
  end
end

class Hash
  def close(k, stop = [])
    self[k].inject(Set.new) do |m, o|
      unless stop.any? { |s| o =~ s }
        m << o
        m += self.close(o, stop)
      end
      m
    end
  end
end

class TestSuites < REXML::Element
  def initialize
    super('testsuites')
  end
end
class TestSuite < REXML::Element
  def initialize(name)
    super('testsuite')
    add_attribute('name', name)
  end
end
class TestCase < REXML::Element
  def initialize(name)
    super('testcase')
    add_attribute('name', name)
  end
end
class Failure < REXML::Element
  def initialize(text = nil)
    super('failure')
    self << Text.new(text) if text
  end
end

#  Define modules.

module TSortMethods
  include TSort
  def tsort_each_node(&block)
    each_key(&block)
  end
  def tsort_each_child(node, &block)
    begin
      self.fetch(node).each(&block)
    rescue IndexError
    end
  end
end

# Process arguments.

def usage
  warn 'close-bundle --host host --port port --path path --repo repo --imports imports_file --iri bundle_iri uri [ uri ...]'
end

log_level = Logger::FATAL
host = port = path = repo = imports_file = bundle_iri = nil

GetoptLong.new(
  [ '--help',    '-h',       GetoptLong::NO_ARGUMENT ],
  [ '--debug',   '-d',       GetoptLong::NO_ARGUMENT ],
  [ '--info',    '-i',       GetoptLong::NO_ARGUMENT ],
  [ '--warn',    '-w',       GetoptLong::NO_ARGUMENT ],
  [ '--repo',    '-r',       GetoptLong::REQUIRED_ARGUMENT ],
  [ '--host',                GetoptLong::REQUIRED_ARGUMENT ],
  [ '--port',                GetoptLong::REQUIRED_ARGUMENT ],
  [ '--imports',             GetoptLong::REQUIRED_ARGUMENT ],
  [ '--iri',                 GetoptLong::REQUIRED_ARGUMENT ],
  [ '--path',                GetoptLong::REQUIRED_ARGUMENT ]
).each do |opt, arg|
  case opt
  when "--help"
    usage
    exit 0
  when "--debug"
    log_level = Logger::DEBUG
  when "--info"
    log_level = Logger::INFO
  when "--warn"
    log_level = Logger::WARN
  when "--host"
    host = arg
  when "--port"
    port = arg
  when "--path"
    path = arg
  when "--repo"
    repo = arg
  when '--imports'
    imports_file = arg
  when '--iri'
    bundle_iri = arg
  else
    warn "unknown option: #{opt}"
    usage
    exit 1
  end
end

unless host && port && path && repo && imports_file && bundle_iri && !ARGV.empty?
  usage
  exit 1
end

named_uris = ARGV

# Open log.

log = Logger.new(STDERR)
log.datetime_format = '%Y-%m-%d %H:%M:%S '
log.level = log_level

# Connect to Sesame server.

log.info('begin session')
session = RDF::Sesame::Session.new(host, port, path, log)
raise 'no session' unless session
log.info('create model')
model = session.model(repo)
raise 'no model' unless model

nsm = {}
namespace_by_prefix = {}
model.namespaces.map do |defn|
  unless (prf = defn.prefix.to_s).empty?
    ns = defn.namespace.to_s
    nsm[prf] = RDF::NamespaceMap.new(ns)
    namespace_by_prefix[prf] = ns
  end
end
RDF::Uri.ns_by_prf = namespace_by_prefix

# Create namespace definition string.

NS_DEFS = nsm.map do |prf, ns|
  "PREFIX #{prf}:#{nsm[prf][''].to_uriref}"
end.join("\n")

# Load imports graph.

imports_by_ontology = YAML.load(File.open(imports_file))['closure']
log.debug("imports_by_ontology: #{imports_by_ontology.inspect}")

# Collect imported ontologies.

log.debug("named ontologies #{named_uris.inspect}")
imported_uris = named_uris.inject(Set.new) do |m, u|
  m += imports_by_ontology[u]
  m
end
log.debug("imported ontologies #{imported_uris.inspect}")
  
imports_by_ontology.extend(TSortMethods)
sorted_ontologies = imports_by_ontology.tsort.reverse
log.debug("sorted_ontologies: #{sorted_ontologies.inspect}")

# Construct query contexts.

log.info('construct query contexts')

from_clauses = {}
from_clauses_without_embedding = {}
from_named_clauses = {}
from_named_clauses_without_embedding = {}
entailments = %w{ /ClassEntailments /PropertyEntailments } << nil
ontology_lists = { 'this' => named_uris, 'imported' => imported_uris }

ontology_lists.each do |key, ontology_list|
  ontology_list_without_embedding = ontology_list.reject { |o| o.to_s =~ EMBEDDING_RE }
  from_clauses[key] = h = {}
  from_clauses_without_embedding[key] = hw = {}
  from_named_clauses[key] = hn = {}
  from_named_clauses_without_embedding[key] = hnw = {}
  entailments.each do |entailment|
    h[entailment] = ontology_list.map { |o| "from #{o.context(entailment)}" }.join(' ')
    hn[entailment] = ontology_list.map { |o| "from named #{o.context(entailment)}" }.join(' ')
    log.debug("from_clauses[#{key}][#{entailment}] = #{h[entailment]}")
    log.debug("from_named_clauses[#{key}][#{entailment}] = #{hn[entailment]}")
    hw[entailment] = ontology_list_without_embedding.map { |o| "from #{o.context(entailment)}" }.join(' ')
    hnw[entailment] = ontology_list_without_embedding.map { |o| "from named #{o.context(entailment)}" }.join(' ')
    log.debug("from_clauses_without_embedding[#{key}][#{entailment}] = #{hw[entailment]}")
    log.debug("from_named_clauses_without_embedding[#{key}][#{entailment}] = #{hnw[entailment]}")
  end
end

# Construct filter lists.

log.info('construct filter lists')

ontology_iri_list = {}
  
ontology_lists.each do |key, ontology_list|
  ontology_iri_list[key] = h = {}
  entailments.each do |entailment|
    h[entailment] = ontology_list.map { |o| o.context(entailment) }
    log.debug("ontology_iri_list[#{key}][#{entailment}] = #{h[entailment].inspect}")
  end
end

# Construct DisjointUnion axioms.

subclass_by_class = Hash.new { |h, k| h[k] = Set.new }
set = 'construct DisjointUnion axioms'
log.debug("set: #{set}")
query = %Q{

  #{NS_DEFS}

  select ?klass ?subclass
  
  #{from_clauses_without_embedding['this'][nil]}
  #{from_named_clauses_without_embedding['this'][nil]}

  where {
    graph ?graph { ?klass rdf:type owl:Class; annotation:isAbstract true . }
    ?subclass rdfs:subClassOf ?klass .

    filter #{equal_any('?graph', ontology_iri_list['this'][nil])}

  }
}
log.debug("#{set} query: #{query}")
model.query({ 'query' => query, 'infer' => 'false' }) do |resp|
  subclass_by_class[resp.klass] << resp.subclass
end
log.debug("subclass_by_class: #{subclass_by_class.inspect}")

#
# Construct output document.

log.info('construct output document')
doc = REXML::Document.new
doc << REXML::DocType.new('rdf:RDF')
doc << rdf = REXML::Element.new('rdf:RDF')
rdf.add_attribute('xmlns:rdf', 'http://www.w3.org/1999/02/22-rdf-syntax-ns#')
rdf.add_attribute('xmlns:owl', 'http://www.w3.org/2002/07/owl#')

rdf << ont = REXML::Element.new('owl:Ontology')
ont.add_attribute('about', bundle_iri)

(named_uris.to_a + imported_uris.to_a).each do |import|
  ont << imp = REXML::Element.new('owl:imports')
  imp.add_attribute('rdf:resource', import)
end

subclass_by_class.each do |klass, subclasses|
  rdf << cd = REXML::Element.new('rdf:Description')
  cd.add_attribute('rdf:about', klass)
  cd << dju = REXML::Element.new('owl:disjointUnionOf')
  dju.add_attribute('rdf:parseType', 'Collection')
  subclasses.each do |subclass|
    dju << scd = REXML::Element.new('rdf:Description')
    scd.add_attribute('rdf:about', subclass)
  end
end

# Write output.

log.info('write output')
doc.write(STDOUT, 2)

# End session.

log.info('end')
session.finish
