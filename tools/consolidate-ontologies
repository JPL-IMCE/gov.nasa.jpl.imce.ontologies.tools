#!/usr/bin/env ruby

#--
#
#    $HeadURL$
#
#    $LastChangedRevision$
#    $LastChangedDate$
#
#    $LastChangedBy$
#
#    Copyright (c) 2008-2014 California Institute of Technology.
#    All rights reserved.
#
#++

require 'getoptlong'
require 'guid'
require 'logger'
require 'tempfile'
require 'time'

require 'jpl/rdf/sesame'

# Define constants.

HOST = 'localhost'
PORT = 8080
PATH = 'openrdf-sesame'
REPO = 'imce-ontologies-dev-staging'

cats = %w{ emof cmof embedding}

annotations = { 'dc' => %w{ title rights type creator description } }

props = {
  'base' => %w{
    aggregationProperty compositeAggregationProperty sharedAggregationProperty 
    inverseAggregationProperty inverseCompositeAggregationProperty inverseSharedAggregationProperty 
  }
}

# Define structs.

# Define variables.

# Define utility functions.

# Process arguments.

def usage
  warn 'consolidate-ontologies --host host --port port --path path --repo repo --emof file --cmof file --embedding file'
end

log_level = Logger::FATAL

host = HOST
port = PORT
path = PATH
repo = REPO

file = {}
iri = {}

GetoptLong.new(
[ '--help',    '-h',       GetoptLong::NO_ARGUMENT ],
[ '--debug',   '-d',       GetoptLong::NO_ARGUMENT ],
[ '--info',    '-i',       GetoptLong::NO_ARGUMENT ],
[ '--warn',    '-w',       GetoptLong::NO_ARGUMENT ],
[ '--clear',   '-c',       GetoptLong::NO_ARGUMENT ],
[ '--repo',    '-r',       GetoptLong::REQUIRED_ARGUMENT ],
[ '--host',                GetoptLong::REQUIRED_ARGUMENT ],
[ '--port',                GetoptLong::REQUIRED_ARGUMENT ],
[ '--path',                GetoptLong::REQUIRED_ARGUMENT ],
[ '--emof',                GetoptLong::REQUIRED_ARGUMENT ],
[ '--cmof',                GetoptLong::REQUIRED_ARGUMENT ],
[ '--embedding',             GetoptLong::REQUIRED_ARGUMENT ]
).each do |opt, arg|
  case opt
  when "--help"
    usage
    exit 0
  when "--debug"
    log_level = Logger::DEBUG
  when "--info"
    log_level = Logger::INFO
  when "--warn"
    log_level = Logger::WARN
  when "--clear"
    clear = true
  when "--host"
    host = arg
  when "--port"
    port = arg
  when "--path"
    path = arg
  when "--repo"
    repo = arg
  when "--emof"
    file['emof'] = arg.to_s
  when "--cmof"
    file['cmof'] = arg.to_s
  when "--embedding"
    file['embedding'] = arg.to_s
  else
    warn "unknown option: #{opt}"
    usage
    exit 1
  end
end

if cats.map { |c| file[c] }.any? { |f| f.nil? }
  usage
  exit 1
end

# Open log.

log = Logger.new(STDERR)
log.datetime_format = '%Y-%m-%d %H:%M:%S '
log.level = log_level

# Connect to Sesame server.

log.info('begin session')
session = RDF::Sesame::Session.new(host, port, path, log)
raise 'no session' unless session
log.info('create model')
model = session.model(repo)
raise 'no model' unless model

nsm = {}
model.namespaces.map do |defn|
  prf = defn.prefix.to_s
  ns = defn.namespace.to_s
  nsm[prf] = RDF::NamespaceMap.new(ns)
end

# Create temporary contexts.

log.info('create temporary contexts')

context = {}
cats.each do |cat|
  uri_string = "http://eis.jpl.nasa.gov/imce/#{Guid.new}"
  context[cat] = RDF::Uri.new(uri_string).to_uriref
  log.debug("#{cat} context: #{context[cat]}")
end

at_exit do

  # Delete temporary contexts.

  log.info('delete temporary contexts')
  cats.each do |cat|
    log.debug("delete context #{context[cat]}")
    model.delete_statements({ 'context' => context[cat] })
  end

  # End session.

  log.info('end session')
  session.finish

end

# Load ontologies and write temporary contexts.

cats.each do |cat|

  # Load this category's axioms.

  log.info("load #{cat} axioms")
  File.open(file[cat]) do |f|

    # Write this category's axioms into temporary context.

    log.info("write #{cat} axioms into temporary context")
    model.import(f, { 'context' => context[cat] })

  end
end

# Find ontology IRIs.

log.info('find ontology iris')
cats.each do |cat|
  sl = model.statements({
    'pred' => nsm['rdf']['type'].to_uriref,
    'obj' => nsm['owl']['Ontology'].to_uriref,
    'context' => context[cat]
  })
  raise "no ontology axiom in #{file[cat]}" if sl.length < 1
  raise "duplicate ontology axioms in #{file[cat]}" if sl.length > 1
  iri[cat] = sl.first.subject
  log.debug("#{cat} iri: #{iri[cat]}")
end

# Integrate ontology annotations and imports.

log.info('integrate ontology annotations and imports')
annotations.each do |prefix, alist|
  alist.each do |name|
    sl = model.statements({
      'subj' => iri['cmof'].to_uriref,
      'pred' => nsm[prefix][name].to_uriref,
      'context' => context['cmof']
    })
    sl.each do |s|
      s.subject = iri['emof'].to_uriref
      log.debug("add #{s.to_s} to emof context")
      model.add_statement(s, { 'context' => context['emof'] })
    end
  end
end

# Move selected cmof axioms to emof ontology.

log.info('move selected cmof axioms to emof ontology')
stmts = model.statements({ 'context' => context['cmof'] }).reject do |s|
  s.subject == iri['cmof']
end
model.add_statements(stmts, { 'context' => context['emof'] })

# Correct embedding ontology imports.

log.info('correct embedding ontology imports')
model.delete_statements({
  'subj' => iri['embedding'].to_uriref,
  'pred' => nsm['owl']['imports'].to_uriref,
  'obj' => iri['cmof'].to_uriref,
  'context' => context['embedding']
})
s = RDF::Statement.new(iri['embedding'], nsm['owl']['imports'], iri['emof'])
model.add_statement(s, { 'context' => context['embedding'] })

# Write updated ontologies.

log.info('write updated files')
cats.reject { |c| c == 'cmof' }.each do |cat|
  log.debug("write file #{file[cat]}")
  File.open(file[cat], 'w') do |f|
    model.export({ 'context' => context[cat] }) do |s|
      f.write(s)
    end
    f.write("\n")
  end
end

# Remove cmof ontology.

log.info('remove cmof ontology')
File.delete(file['cmof'])

# Exit.

exit
