#!/usr/bin/env ruby

#--
#
#    $HeadURL$
#
#    $LastChangedRevision$
#    $LastChangedDate$
#
#    $LastChangedBy$
#
#    Copyright (c) 2008-2014 California Institute of Technology.
#    All rights reserved.
#
#++

require 'getoptlong'
require 'logger'
require 'open-uri'
require 'tempfile'
require 'time'

require 'jpl/rdf/sesame'

# Define constants.

EXTRACT_CMD = 'pellet extract -l OWLAPIv3 --ignore-imports'

STATEMENT_TYPES = {
  'DefaultStatements' => false,
  'AllClass' => false,
  'AllIndividual' => false,
  'AllProperty' => false,
  'AllStatements' => false,
  'AllStatementsIncludingJena' => false,
  'ClassAssertion' => false,
  'ComplementOf' => false,
  'DataPropertyAssertion' => false,
  'DifferentIndividuals' => false,
  'DirectClassAssertion' => false,
  'DirectSubClassOf' => false,
  'DirectSubPropertyOf' => false,
  'DisjointClasses' => false,
  'DisjointProperties' => false,
  'EquivalentClasses' => true,
  'EquivalentProperties' => true,
  'InverseProperties' => true,
  'ObjectPropertyAssertion' => false,
  'PropertyAssertion' => false,
  'SameIndividual' => false,
  'SubClassOf' => true,
  'SubPropertyOf' => true
}

# Define variables.

imports_by_ontology = Hash.new { |h, k| h[k] = Set.new }

# Define utility functions.

class Hash
  def close(k)
    self[k].inject(Set.new) do |m, v|
      m << v
      m += self.close(v)
    end
  end
end

# Process arguments.

def usage
  warn 'entail --host host --port port --path path --repo repo'
end

log_level = Logger::FATAL
host = port = path = repo = uri_pattern = file_pattern = nil

GetoptLong.new(
[ '--help',    '-h',       GetoptLong::NO_ARGUMENT ],
[ '--debug',   '-d',       GetoptLong::NO_ARGUMENT ],
[ '--info',    '-i',       GetoptLong::NO_ARGUMENT ],
[ '--warn',    '-w',       GetoptLong::NO_ARGUMENT ],
[ '--repo',    '-r',       GetoptLong::REQUIRED_ARGUMENT ],
[ '--host',                GetoptLong::REQUIRED_ARGUMENT ],
[ '--port',                GetoptLong::REQUIRED_ARGUMENT ],
[ '--path',                GetoptLong::REQUIRED_ARGUMENT ]
).each do |opt, arg|
case opt
when "--help"
  usage
  exit 0
when "--debug"
  log_level = Logger::DEBUG
when "--info"
  log_level = Logger::INFO
when "--warn"
  log_level = Logger::WARN
when "--host"
  host = arg
when "--port"
  port = arg
when "--path"
  path = arg
when "--repo"
  repo = arg
else
  usage
  exit 1
end
end

unless host && port && path && repo
  usage
  exit 1
end

# Open log.

log = Logger.new(STDERR)
log.datetime_format = '%Y-%m-%d %H:%M:%S '
log.level = log_level

# Connect to Sesame server.

log.info('begin session')
session = RDF::Sesame::Session.new(host, port, path, log)
raise 'no session' unless session
log.info('create model')
model = session.model(repo)
raise 'no model' unless model

# Create namespace definition string.

NS_DEFS = model.namespaces.map do |nss|
  "PREFIX #{nss.prefix.to_s}:#{RDF::Uri.new(nss.namespace.to_s).to_uriref}"
end.join("\n")

# Find ontologies and imports.

log.info('find ontologies and imports')
qstring = %Q{
  #{NS_DEFS}
  select distinct ?ontology ?import
  where {
    ?ontology rdf:type owl:Ontology .
    ?ontology owl:imports ?import .
  }
}
log.debug(qstring)
model.query({'query' => qstring, 'infer' => 'false'}) do |resp|
  ontology = RDF::Uri.new(resp.ontology.to_s)
  import = RDF::Uri.new(resp.import.to_s)
  imports_by_ontology[ontology] << import
  log.debug("#{ontology} imports #{import}")
end

# Find transitive closure of all imports.

imports_by_ontology.each_key do |ontology|
  imports_by_ontology[ontology] = imports_by_ontology.close(ontology)
end

# Iterate over ontologies.

imports_by_ontology.each do |ontology, imports|

  # Extract assertions.

  assertions = model.export({'context' => imports.add(ontology).map { |i| i.to_uriref }})
  log.debug("#{ontology} assertions: #{assertions}")
  log.info("#{ontology} assertions: #{assertions.length} bytes}")

  # Calculate entailments and add to repository.

  Tempfile.open('.extract') do |tf|
    tf.write(assertions)
    tf.flush

    STATEMENT_TYPES.select { |type, bool| bool }.map { |a| a.first }.each do |type|

      # Calculate entailments.

      entailments = ''
      cmd = %Q{sh -c "#{EXTRACT_CMD} -s #{type} file:#{tf.path} 2> /dev/null"}
      log.debug(cmd)
      IO.popen(cmd) do |io|
        entailments << io.read
      end
      log.debug("#{ontology} entailments: #{entailments}")
      log.info("#{ontology} #{type} entailments: #{entailments.length} bytes")

      # Delete entailments from repository.

      context = RDF::Uri.new("#{ontology}-#{type}").to_uriref
      log.info("delete statements from context #{context}")
      model.delete_statements({'context' => context})
      log.info("repository size: #{model.size} statements")

      # Add to repository.

      log.info("add entailments to context #{context}")
      model.import(entailments, {'context' => context})
      log.info("repository size: #{model.size} statements")

    end
  end
end

# End session.

log.info('end session')
session.finish
